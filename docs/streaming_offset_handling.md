# Streaming Scanner Offset-Based Data Access

## Overview

This document describes the changes made to handle offset-based data access in YARA-X's streaming scanners (`StreamingScanner` and `MultiStreamScanner`).

## Problem

When using streaming scanners, data is processed in chunks. YARA rules that use offset-based expressions (e.g., `@pattern[1] + 16`) can reference data that is no longer in memory:

```yara
rule example {
    strings:
        $event = "EVENT"
    condition:
        $event and uint32(@event[1] + 16) == 0x41424344
}
```

If `$event` matches in chunk 1, but the data at `@event[1] + 16` is in chunk 2 (or was in a previous chunk), the scanner would either:
1. Read incorrect data from the wrong offset in the current chunk
2. Cause an error when trying to access out-of-bounds memory

## Solution

Modified the `gen_xint_fn` macro in `lib/src/wasm/mod.rs` to handle global offsets correctly in streaming mode.

### Key Changes

1. **Detect Streaming Mode**: Check if `global_scan_offset > 0` to determine if we're in streaming mode
2. **Validate Offset Range**: Ensure the requested global offset falls within the current chunk's boundaries
3. **Convert Offsets**: Transform global offsets to chunk-relative offsets for data access
4. **Graceful Failure**: Return `None` when data is outside the current chunk

### Implementation

```rust
// In streaming mode, we need to handle global offsets correctly
let ctx = caller.data();
let actual_offset = if ctx.global_scan_offset > 0 {
    // We're in streaming mode - need to convert global offset to chunk-relative
    let global_offset = offset;
    
    // Check if the requested global offset is within the current chunk
    if global_offset < ctx.global_scan_offset as usize || 
       global_offset >= (ctx.global_scan_offset + ctx.scanned_data_len as u64) as usize {
        // Offset is outside current chunk - return None
        return None;
    }
    
    // Convert to chunk-relative offset
    (global_offset as u64 - ctx.global_scan_offset) as usize
} else {
    // Regular scanning mode - use offset as-is
    offset
};
```

## Behavior

### When offset-based data IS available in current chunk:
- Pattern matches in chunk 1 at offset 6
- Rule checks `uint32(@pattern[1] + 6)` (offset 12)
- Chunk 2 starts at offset 12 and contains the required data
- **Result**: Read succeeds, rule can match

### When offset-based data is NOT available:
- Pattern matches in chunk 1 at offset 0
- Rule checks `uint32(@pattern[1] + 6)` (offset 6)
- Chunk 2 starts at offset 20 (offset 6 is in the past)
- **Result**: Read returns `None`, rule doesn't match

### Empty chunks:
- Calling `scan_chunk(&[])` re-evaluates rules without new data
- Offset-based reads return `None` since no data is available

## Affected Functions

The change affects all functions generated by the `gen_xint_fn` macro:
- `uint8()`, `uint16()`, `uint32()`
- `uint8be()`, `uint16be()`, `uint32be()`
- `int8()`, `int16()`, `int32()`
- `int8be()`, `int16be()`, `int32be()`

## Testing

Added comprehensive tests in `lib/src/scanner/streaming_tests.rs`:
- `test_offset_access_streaming()`: Verifies offset handling across chunks
- `test_offset_out_of_bounds()`: Tests behavior with out-of-bounds offsets

## Limitations

This solution ensures correctness but means that rules using offset-based data access may not match in streaming mode if the required data spans chunk boundaries. Users should:

1. Use larger chunk sizes when rules contain offset expressions
2. Consider using overlapping chunks for critical offset-based rules
3. Use regular `Scanner` for rules that require extensive offset-based access